\documentclass[paper=a4, fontsize=11pt, twocolumn]{article}

\usepackage[utf8]{inputenc}
\usepackage{fourier}
\usepackage[cache=false]{minted}

\usepackage[francais]{babel} %% installer texlive-lang-french pour cela


\title{Projet 2 : Fouine}
\usepackage{hyperref}

\author{Guillaume Duboc, Pierre Oechsel}

\date{\today}

\usepackage{tikz}
\usepackage{amsmath}

\usetikzlibrary{shapes,positioning}

\begin{document}

\maketitle


\section{Présentation}
Nous présentons ici notre projet \textsc{Fouine}. La grande majorité et implementé en Ocaml avec quelques scripts de tests en bash.
Pour le parseur, on utilise lex et yacc via leurs libs Ocaml.

Nous avons obtenu un micro-language gérant les modules, ayant de l'inférence de types, des types sommes et alias. Du côté de la compilation, nous avons une compilation vers machine Secd et un prototype de machine Zinc sans la récursion.


Nous somme heureux de rejoindre une liste de langage telle que présentés par \cite{Landin}

\setminted{breaklines=true}

\section{Environnement et indices de Bruijn}
\subsection{Un environnement de rêve}

Le module Dream contient deux modules d'environnement : DreamEnv et Dream qui servent respectivement à l'exécution et à l'indiciation par De Bruijn. Leurs structure sont proches, et c'est normal : l'indiciation se fait à peu près dans l'ordre où seront effectuées les appels de variables lors de l'exécution.

J'ai créé cet environnement avec ces contraintes en tête :
\begin{itemize}
	\item accès au n-ième élément en O(1) 
	\item taille dynamique
	\item opérations de pile en O(1) amorti
\end{itemize}

Au cours d'une discussion, il m'est apparu qu'un array géré dynamiquement avec un indice de pile conviendrait.

Type utilisé :
\begin{minted}{ocaml}
type 'a dream = {mutable ssize:int ; mutable size:int ; mutable arr:('a item array) ; mutable start:int }
\end{minted}

La fonction add va "push" un élément et incrémenter 

On double la taille de l'array chaque fois qu'il est trop petit. D'où la complexité amortie sympathique.
Il faudrait que si on retire un élément et que l'array a 4 fois moins d'éléments que sa taille, on le réduise (les augmentations / réduction d'espace doivent être asymétriques pour éviter le cas où on ajoute puis retire un élément limite) : cela n'a pas été encore implémenté.

\subsection{De Bruijn}
L'indiciation par De Bruijn, c'est fantastique : après ce pre-process, il n'y a plus aucun identifiant et les erreurs de scope deviennent virtuellement impossibles.
Dans les papiers que j'ai survolé, celle-ci est toujours définie dans des cadres très théoriques de $\lambda$-calcul. Du coup, j'ai transformé les ast de fonctions en abstractions Lambda et LambdaR, et je me suis débrouillé au cas par cas pour l'implémentation.

Cas particuliers :
\begin{itemize}
	\item les fonctions récursives
	\begin{minted}{ocaml}
	| In (LetRec ((Ident(f, _)), Fun ((Ident(x, _)), a, _), _), b, _) ->
	let d' = Dream.copy d in
	begin
	Dream.add d (string_of_ident f);  (* accès via ACC 2 *)
	Dream.add d (string_of_ident x);  (* accès via ACC 1 *)
	let new_a = aux d a in
	begin
	Dream.add d' (string_of_ident f);
	LetIn (LambdaR (new_a), aux d' b)
	end
	end
	\end{minted}
	\item les tuples : le contextes d'évaluation de chacuns des éléments d'un tuple sont indépendants les uns des autres, d'où la copie successive de l'environnement d'indiciation d : 
	\begin{minted}{ocaml}
	| Tuple (l, _) ->
	let f d a = let d' = Dream.copy d in aux d' a
	in let l' = List.map (f d) l2
	\end{minted}
\end{itemize}

\section{Compilation}
\subsection{Tuples}
Pour gérer les tuples généralisés, il faut pouvoir dupliquer l'environnement d'où l'instruction DUPL et SWAP pour récupérer un environnement.
L'idée est tiré de \cite{cousineau}

\subsection{Les unit values ou la mort du fonctionnel pur}
Les instructions de la forme 
begin e1; e2 end sont embêtantes pour la compilation. En effet, si e1 est par exemple 2, alors on va push une CST 2 dans la pile, qui pourrait interférer avec la suite.
Normalement il n'y a pas de problèmes : on peut laisser ces éléments "traîner". Par contre il y a un soucis avec la gestion des unit et le fonctionnel.
L'instruction RETURN nécessite de renvoyer une valeur. C'est pourquoi on a besoin de renvoyer une UNITVALUE dans le cas d'une fonction typée unit. Donc pour toute instruction renvoyant un type unit, on push UNITVALUE sur la pile. Le risque d'interférences augmente de plus en plus.
La solution est d'ignorer les UNIT value lorsque l'on pop un élément si c'est pour autre chose que l'instruction RETURN, qui elle accepte de renvoyer le type unit (qui est présent dans la repl d'ailleurs).

Une possibilité serait d'utiliser l'inférence de types pour faire du garbage collecting, ou d'ajouter une instruction "DROP" qui retire les valeurs qui n'ont rien à faire sur la pile (notamment dans des séquences d'instructions)

Dans la ZINC, comme on utilise un accumulateur et que seule l'instruction PUSH envoie des valeurs sur la pile, on a pas ce problème.

\subsection{Ordre d'évaluation}
Dans ZINC (voir \cite{leroyzinc}), f N1 N2 ... Nk se compile en $[|N_k\|]$; PUSH; $[|N_{k-1}|]$; PUSH; ...; $[|N_1|]$ [|f|] alors que dans la SECD comme les fonctions à plusieurs paramètres sont transformées en fonctions d'arité 1, c'est plutôt
[|f|] $[|N_1]$ $[|N_2|]$. Cela empêche la SECD de coller exactement à Ocaml qui est compilé via une ZINC machine.

\subsection{Le pattern matching en compilation}
De notre point de vue, il n'y a pas de manière satisfaisante d'implémenter le pattern matching dans la compilation car il y aurait une explosion du nombre d'instructions possible (avec des instructions du type CONSTRUCTOR of 'a et TYPECHECK $((constructor_type * code) list))$.




\section{Inférence}
L'écriture de l'inférence de type c'est basé en deux étapes.
\subsection{Inférence, Version Home made}
Lors d'une premiére étape j'ai tenté d'écrire une inférence de type from scratch, c'est à dire en me basant sur un prototype de programme typant une systéme du type Lambda Calcul avec un algorithme de \href{https://en.wikipedia.org/wiki/Hindley\%E2\%80\%93Milner_type_system}{Hindley Milner}. Il s'agit donc d. Cette version eu une durée de vie relativement longue, du rendu 2 à une semaine avant le rendu 3, mais fut abandonné car trop dur à maintenir. En effet, le code de cette inférence (dont nous pouvons encore trouvé le code dans le fichier \textit{inference\_old.ml})  a vu sa complexité croitre au fur et à mesure des bugfix.

Ci-dessus nous expliquons plusieurs bugs encouru et leur solution
\subsubsection{Generalisation des fonctions dans l'environnement}
Un des premiers bugs à être apparu est le fait qu'une fonction dans l'environnement jusqu'à alors de type \mintinline{ocaml}{'a -> 'a -> bool} était spécifié en \mintinline{ocaml}{int -> int -> bool} aprés une premiére utilisation.
Un exemple de cas ou cela apparaissait:
\begin{minted}{ocaml}
>> let f a b = 4;;
	val f : 'a -> 'a -> int
>> f 5 5;;
	int : 4
>> f;;
	int -> int -> int : <fun>
\end{minted}
Un fix fut de dupliquer les types.
\subsubsection{Conséquence de ce bug}
Dupliquer les types ne suffit pas: Que se passe-t-il quand on évalue let temp f = f 0? Le type de temp est \mintinline{ocaml}{'a -> 'b}, au lieu de \mintinline{ocaml}{(int -> 'a) -> 'b} car nous avons copié le type de f avant de travailler dessus. On introduit donc un nouveau type, Arg\_type, nous permettant de savoir si un type stocké vient d'un argument ou non. Un argument ne peut qu'être spécialisé, nous ne devons pas le copier, alors qu'un type défini par un let normal ne peut pas être plus spécialisé. 
Mais un autre problème se lève avec une expression de la forme: \mintinline{ocaml}{let f e = let (x, y) = e in x} (qui a alors le type \mintinline{ocaml}{'a * 'b -> 'c} au lieu de \mintinline{ocaml}{'a * 'b -> 'a}). En effet, en récupérant x, on copie son type. Mais x a un type 'a! Or en caml aucun identifiant valable ne peut avoir de type 'a: on ne doit donc pas copier son type.
\subsubsection{Autre bug}
Le typage de fibo (\mintinline{ocaml}{let fibo n = let rec aux a b i = if i = n then a else aux b (a+b) (i+1) in aux 0 1 0;;}), était mal fait et était \mintinline{ocaml}{'a -> int}. En effet, lors de l'unification, si on unifie un 'a avec un autre type, on unifie ce 'a en particulier (il n'y a pas vraiment de pointeurs en caml, et même en C++ la tache serait non triviale: on veut, étant donné $a_1,\cdots,a_n$ pointant vers le même objet, et $b_1, \cdots, b_m $ pointant vers un même autre objet, faire pointer les $a_i$ et $b_i$ vers le même objet et ainsi de suite). Pour contrer ce problème, on ajoute dans une hashmaps ces affectations (du type 'a := int), puis dans un postprocess, on résout les 'a non affecté à l'aide de ce hashmaps (on parcours le type, si on voit un 'a on regarde s'il a été affecté), et on itère cette procédure tant que quelque chose bouge (car on pourrait introduire d'autres 'b non correctement unifiés).

\subsection{Deuxième version}
La première inférence étant extremement bugués, nous sommes passé à un second algorithme d'inférence. Celui est grandement inspirée de l'algorithme d'inférence par les levels de Caml, et suit l'explication de \cite{Type}. Cette inférence de type est bien plus stable et fiable que la précedente.

\subsection{Commentaire sur l'inférence}
L'inférence ne géneralise pas les types \mintinline{ocaml}{ref} (question de soundness). Elle fonctionne aussi avec les types définis par l'utilisateurs (types declaration, comme \mintinline{ocaml}{type test = int}, ou type somme comme \mintinline{ocaml}{type test\_sum = Un | Deux}). Une attention particuliére a été apporté lors de l'unifaction de deux types crées par l'utilisateur. Nous voulons que lorsque l'utilisateur utilise le type test utilisé précedemment, \textsc{Fouine} renvoie le type test est non \mintinline{ocaml}{int}. Vous pouvez voir dans le fichier \textit{inference.ml}, plus particuliérement dans la fonction \textsc{unify} pour plus de détails.

Une chose est amusante à constater. Avec la transformation par CPS plusieurs fonctions ne peuvent être typés, comme \mintinline{ocaml}{let rec fact n = if n = 0 then 1 else n * fact (n-1) in fact;;}. Cela n'est pas un bug (notamment à cause des points fixes \ref{pointsfixes}). Nous utilisons les points fixes pour simuler la récursion, et donc nous nous restreignons presque entiérement à du lambda calcul. Si toutes l'inférence est désactivée (option "-noinference"), tout fonctionne correctement.

\section{Environnements}
Nous utilisons des environnements imbriqués en \textsc{Fouine} (voir \ref{env_fig}). Cela nous a permis d'implémenter aisément des modules dans l'interpretation.

\subsection{Sous-environnements}
Les sous-environnements sont les briques de bases des environnement interprétés Fouine. Ils sont divisés en trois champs:
\begin{itemize}
	\item mem: contient les bindings des variables et fonctions
	\item types: contient les bindings des types des variables et fonctions
	\item user\_defined\_types: contient les types définis par l'utilisateur
\end{itemize}

Il est intéressant de noté que mem et types réecrasent leur bindings: les fonctions ont des closures referencant à la valeur de leur environnement lors de leur création. Ce n'est pas le cas pour user\_defined\_types. Nous avons en effet décidé de simuler des closures sur les types en se basant sur un systéme d'identifiant de chaque type: les types créer par l'utilisateur disposent d'un identifiant (un int) en plus d'un nom, et cette identifiant sert à réferer au bon type au cours de l'interpretation. Ne pas passer par le même type de closure est intentionnelle et sert à montrer que nous pouvons nous en passer justement.

\subsection{Modules}
Grâce à notre systéme d'environnement implémenter les modules est aisé. Il suffit de suivre le chemin des noms de modules jusqu'au bon sous-environnement. 
Nous n'avons pas implementé la commande "open" mais un chargement de module à partir d'un fichier est disponible. Dans le cas ou l'interpreteur reconnait un module qu'il n'a pas, mettons dans l'expression \mintinline{ocaml}{let a = List.a;;}, il effectue un bfs pour trouver un fichier de nom correspondant et le charge comme module dans l'environnement.

\subsection{Buildins}
Nous préchargeons dans l'environement des fonctions utiles. Elles sont en deux types:
\begin{itemize}
	\item Fonctions buildins; ce sont des fonctions que nous ne pouvons  simuler en Fouine, comme l'addition, ou la multiplication. Elles sont désactivable avec l'option -nobuildins (voir désactiver automatiquement si besoin).
	\item Fonctions Fouine. Nous préchargeons également quelques fonctions Fouine (peu car ce n'était pas notre objectif principal). C'est ainsi que les listes sont implementés.
\end{itemize}
Ces fonctions buildins sont compatibles avec les diverses transformations.


\section{Autres}
\subsection{Intérpretation}
L'interpretation en elle même ce base sur des continuations. Celle-ci fut longue à mettre en place, comme le montre son état de non-fonctionnement aprés le rendu 2. Mais une fois les problèmes résolues, celle-ci marche sans trop de bug.
\subsection{Petit mots sur les transformations}
Les transformations sont incompatible (ou en tout cas leur comportement est non testé) avec la compilation car elles font un usage intensif de fonctionnalités non implementés dans la compilation (constructeurs, matching...).

\paragraph{Points fixes} \label{pointsfixes}
Pour simuler les fonctions récursives tout en restant dans l'état d'esprit du lambda-calcul nous utilisons les points fixes. Ci-dessous nous donnons la définition d'un point fixe et un exemple d'utilisation:

\begin{minted}{ocaml}
>> type 'a fix = Fix of ('a fix -> 'a);;
>> let y t = let p (Fix f) x = t (f (Fix f)) x in p (Fix p);;
>> let fact = let t_fact f x = 
if x = 0 then 1 else x * f (x - 1) 
in y t_fact
\end{minted}


Nous avons fait en sorte que les transformations soit compatible avec la repl et utilise uniquement du Fouine: les fonctions pour simuler les réferences, les points fixes...




\section{Travaux futures}
\paragraph{Guillaume}
\begin{itemize}
	\item Avoir le temps de rationnaliser les instructions d'Ocaml en $\lambda$-calcul, que j'ai beaucoup rencontré lorsque je cherchais à me renseigner sur les substitutions pour De Bruijn.
	
	\item Passer un peu plus de temps sur la ZINC, et continuer à explorer les pistes évoquées dans les slides de Xavier Leroy citées dans le sujet du rendu.
	
	\item Quand elles seraient entièrement implémentées, comparer en détail les machines SECD et ZINC. Plutôt observer des données comme les tailles des structures de données que la rapidité : celle-ci est biaisée puisqu'on a pas codé avec ça en tête en général.
\end{itemize}

\paragraph{Pierre}
\begin{itemize}
	\item Commencer par interpreter la commande Open
	\item Nettoyer et refactorer de maniére intensive le code. Celui-ci a grandit trés rapidement et sa structure n'a pas été conçu pour les derniers développements (modules entre autre), ce qui rends sa structure difficile à lire et modifier.
	\item débugger
	\item Implémenter un Typeur plus performant pour les transformations CPS (qui sont du lambda calcul)
	\item Regarder du côté des functors, car ça à l'air marrant et casse tête à implémenter.
\end{itemize}

\begin{figure*}[p]
	
	\centering
	\label{env_fig}
		\begin{tikzpicture}
		[sibling distance=30em,
		every node/.style = {shape=rectangle, rounded corners,
			draw, align=center,
		},
		level 2/.style={sibling distance=20em},
		]
		\node{$\begin{array}{l}
			"":\\
			\left\lbrace\begin{array}{l}
			\text{mem} \\
			\text{types} \\	
			\text{user defined types}
			\end{array}\right.\end{array}$}
		child {
			node {	$\begin{array}{l}
				"List":\\
				\left\lbrace\begin{array}{l}
				\text{mem} \\
				\text{types} \\
				\text{user defined types}
				\end{array}\right.\end{array}$}}
		child{	node {$\begin{array}{l}
				"Test":\\
				\left\lbrace\begin{array}{l}
				\text{mem} \\
				\text{types} \\
				\text{user defined types}
				\end{array}\right.\end{array}$}
			child{node{$\begin{array}{l}"Foo":\\\left\lbrace\cdots\right.\end{array}$}}	
			child{node{$\begin{array}{l}"Bar":\\\left\lbrace\cdots\right.\end{array}$}	
		}};;
		
		
		\end{tikzpicture}
\caption{Environnement fouine}
\end{figure*}

\bibliographystyle{plain}
\bibliography{bibli} 
\end{document}
% ci-dessous: commenté car non offert sur les machines libre-service.
% décommentez si vous le souhaitez.
%\usepackage[french]{babel}

% pour compiler: 

% faire    pdflatex ex-rapport
% (si les references aux numeros de parties apparaissent comme des
% "?", recompiler une fois)

% la compilation de la bibliographie est davantage une "incantation":
% faire     bibtex ex-biblio
% puis      pdflatex ex-rapport (un nombre premier de fois)


% vous pouvez ensuite ouvrir le fichier ex-rapport.pdf




